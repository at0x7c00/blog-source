---
title: 线程并发工具--线程安全集合
date: 2014-10-18 18:29
categories: 多线程
tags: 
---

一般的集合，如ArrayList、HashSet、HashMap等，都是线程不安全的。不安全的表现是什么？
ConcurrentModifyException
都知道，在遍历集合的时候不能对集合进行添加和删除操作，否则就会抛这个一场。如果一个线程正在遍历一个集合的时候另外一个线程往这个集合中增加或删除了元素，那么程序就会出这个异常。
这个异常的原理是，集合中有一个版本号，每次修改（添加或删除）集合的时候，版本号都会往上涨。当开始遍历集合的时候，先记录下这个版本号，在遍历期间，如果发现这个版本号和集合当前的版本号不等，就会抛这个异常。
死循环
集合的hasNext方法实现如下：
```java
        public boolean hasNext() {
            return cursor != size;
        }
```
判断的是当前的游标是否和集合的大小相等。 当一个线程在遍历集合的时候，cursor是一直往上涨的，直到“遇到"cursor==size()。一种情况是，刚好在这个线程快要结束遍历，即游标的值刚好等于size的时候，另外一个线程不小心从集合中remove了一个元素，那么size()就减小了，cursor不等于size了，然后cursor继续往上涨。这样，cursor就和size擦肩而过，永远也不能" 相见"了，于是死循环了。

为此，Java提供了线程安全的集合，例如ConcurrentHashMap,CopyOnWriteArrayList。这些集合是线程安全的。不会出现ConcurrentModifyException和死循环的问题。
